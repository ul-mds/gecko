"""
The generator module provides generator functions for generating realistic data.
These generators wrap around common data sources such as frequency tables and numeric distributions.
"""

__all__ = [
    "Generator",
    "from_function",
    "from_uniform_distribution",
    "from_normal_distribution",
    "from_frequency_table",
    "from_multicolumn_frequency_table",
    "from_datetime_range",
    "to_data_frame",
]

from os import PathLike
from typing import Callable, Optional, Union, Literal

import numpy as np
import pandas as pd
from typing_extensions import ParamSpec  # required for 3.9 backport

P = ParamSpec("P")
Generator = Callable[[int], list[pd.Series]]


def from_function(func: Callable[P, str], *args: object, **kwargs: object) -> Generator:
    """
    Generate data from an arbitrary function that returns a single value at a time.

    Notes:
        This function should be used sparingly since it is not vectorized.
        Only use it for testing purposes or if performance is not important.

    Args:
        func: function to invoke to generate data from
        *args: positional arguments to pass to `func`
        **kwargs: keyword arguments to pass to `func`

    Returns:
        function returning list with strings generated from custom function
    """

    def _generate(count: int) -> list[pd.Series]:
        return [pd.Series(data=[func(*args, **kwargs) for _ in np.arange(count)])]

    return _generate


def from_uniform_distribution(
    low: Union[int, float] = 0,
    high: Union[int, float] = 1,
    precision: int = 6,
    rng: Optional[np.random.Generator] = None,
) -> Generator:
    """
    Generate data from a uniform distribution.

    Args:
        low: lower limit of uniform distribution (inclusive)
        high: upper limit of uniform distribution (exclusive)
        precision: decimal precision of the numbers generated from the uniform distribution
        rng: random number generator to use

    Returns:
        function returning list with numbers drawn from a uniform distribution formatted as strings
    """
    if rng is None:
        rng = np.random.default_rng()

    format_str = f"%.{precision}f"

    def _generate(count: int) -> list[pd.Series]:
        return [pd.Series(np.char.mod(format_str, rng.uniform(low, high, count)))]

    return _generate


def from_normal_distribution(
    mean: float = 0,
    sd: float = 1,
    precision: int = 6,
    rng: Optional[np.random.Generator] = None,
) -> Generator:
    """
    Generate data from a normal distribution.

    Args:
        mean: mean of the normal distribution
        sd: standard deviation of the normal distribution
        precision: decimal precision of the numbers generated from the normal distribution
        rng: random number generator to use

    Returns:
        function returning list with numbers drawn from a normal distribution formatted as strings
    """
    if rng is None:
        rng = np.random.default_rng()

    format_str = f"%.{precision}f"

    def _generate(count: int) -> list[pd.Series]:
        return [pd.Series(np.char.mod(format_str, rng.normal(mean, sd, count)))]

    return _generate


def from_frequency_table(
    csv_file_path: Union[str, PathLike[str]],
    value_column: Union[str, int] = 0,
    freq_column: Union[str, int] = 1,
    encoding: str = "utf-8",
    delimiter: str = ",",
    rng: Optional[np.random.Generator] = None,
) -> Generator:
    """
    Generate data from a frequency table.
    The frequency table must be provided in CSV format and contain at least two columns: one containing values to
    generate and one containing their assigned absolute frequencies.
    Values generated by this function will have a distribution similar to the frequencies listed in the input file.
    If the value and frequency column are provided as strings, then it is automatically assumed that the CSV file
    has a header row.

    Args:
        csv_file_path: path to CSV file
        value_column: name or index of the value column
        freq_column: name or index of the frequency column
        encoding: character encoding of the CSV file
        delimiter: column delimiter of the CSV file
        rng: random number generator to use

    Returns:
        function returning list with single series containing values generated from the input file
    """
    if rng is None:
        rng = np.random.default_rng()

    if type(value_column) is not type(freq_column):
        raise ValueError("value and frequency columns must be of the same type")

    # skip check for value_column bc they are both of the same type already
    if not isinstance(freq_column, str) and not isinstance(freq_column, int):
        raise ValueError(
            "value and frequency columns must be either a string or an integer"
        )

    header = isinstance(freq_column, str)

    # read csv file
    df = pd.read_csv(
        csv_file_path,
        header=0 if header else None,  # header row index (`None` if not present)
        usecols=[value_column, freq_column],
        dtype={freq_column: "int", value_column: "str"},
        keep_default_na=False,
        sep=delimiter,
        encoding=encoding,
    )

    # convert absolute to relative frequencies
    srs_value = df[value_column]
    srs_prob = df[freq_column] / df[freq_column].sum()

    def _generate(count: int) -> list[pd.Series]:
        return [pd.Series(rng.choice(srs_value, count, p=srs_prob))]

    return _generate


def from_multicolumn_frequency_table(
    csv_file_path: Union[str, PathLike[str]],
    value_columns: Union[int, str, list[int], list[str]] = 0,
    freq_column: Union[int, str] = 1,
    encoding: str = "utf-8",
    delimiter: str = ",",
    rng: Optional[np.random.Generator] = None,
) -> Generator:
    """
    Generate data from a frequency table with multiple interdependent columns..
    The frequency table must be provided in CSV format and contain at least two columns: one containing values to
    generate and one containing their assigned absolute frequencies.
    Values generated by this function will have a distribution similar to the frequencies listed in the input file.
    If the values and frequency column are provided as strings, then it is automatically assumed that the CSV file
    has a header row.

    Args:
        csv_file_path: path to CSV file
        value_columns: names or indices of the value columns
        freq_column: name or index of the frequency column
        encoding: character encoding of the CSV file
        delimiter: column delimiter of the CSV file
        rng: random number generator to use

    Returns:
        function returning list with as many series as there are value columns specified containing values generated from the input file
    """
    if rng is None:
        rng = np.random.default_rng()

    # coalesce into list
    if not isinstance(value_columns, list):
        value_columns = [value_columns]

    # check that list is not empty
    if len(value_columns) == 0:
        raise ValueError("value column list cannot be empty")

    # peek at type of first value column
    if type(value_columns[0]) is not type(freq_column):
        raise ValueError("value and frequency columns must be of the same type")

    # skip check for value_columns bc they are both of the same type already
    if not isinstance(freq_column, str) and not isinstance(freq_column, int):
        raise ValueError(
            "value and frequency column must be either a string or an integer"
        )

    # now check that all other entries in the value column are of the same type as the first entry
    # (which has been validated already)
    for i in range(1, len(value_columns)):
        if not isinstance(value_columns[i], type(value_columns[0])):
            raise ValueError(
                "value and frequency column must be either a string or an integer"
            )

    header = isinstance(freq_column, str)

    df = pd.read_csv(
        csv_file_path,
        header=0 if header else None,
        usecols=value_columns + [freq_column],
        dtype={
            freq_column: "int",
            **{value_column: "str" for value_column in value_columns},
        },
        keep_default_na=False,
        sep=delimiter,
        encoding=encoding,
    )

    # sum of absolute frequencies
    freq_total = df[freq_column].sum()
    # new series to track the relative frequencies
    value_tuple_list = list(zip(*[list(df[c]) for c in value_columns]))
    rel_freq_list = list(df[freq_column] / freq_total)

    # noinspection PyTypeChecker
    def _generate(count: int) -> list[pd.Series]:
        x = rng.choice(value_tuple_list, count, p=rel_freq_list)
        return [pd.Series(list(t)) for t in zip(*x)]  # dark magic

    return _generate


def from_datetime_range(
    start_dt: Union[str, np.datetime64],
    end_dt: Union[str, np.datetime64],
    dt_format: str,
    unit: Literal["D", "h", "m", "s"],
    rng: Optional[np.random.Generator] = None,
) -> Generator:
    """
    Generate data from a range of dates and times.
    The start and end datetime must be provided either as a ISO 8601 datetime string or a NumPy datetime object.
    The output format must include the same format codes as specified in the `datetime` Python module for the
    `strftime` function.
    The unit specifies the smallest unit of time that may change when generating random dates and times.
    For example if `D` is specified, generated dates will only differ in their days, months and years, leaving hours,
    minutes and seconds unaffected.
    The same applies for `h`, `m` and `s` for hours, minutes and seconds respectively.

    Args:
        start_dt: datetime string or object for start of range
        end_dt: datetime string or object for end of range
        dt_format: output format for generated datetimes
        unit: smallest unit of time that may change when generating random dates and times
        rng: random number generator to use

    Returns:
        function returning list of random datetime strings within the specified range
    """
    if isinstance(start_dt, str):
        start_dt = np.datetime64(start_dt)

    if isinstance(end_dt, str):
        end_dt = np.datetime64(end_dt)

    if start_dt >= end_dt:
        raise ValueError(
            f"start datetime `{start_dt}` is greater than end datetime `{end_dt}`"
        )

    if rng is None:
        rng = np.random.default_rng()

    def _generate(count: int) -> list[pd.Series]:
        delta_td = end_dt - start_dt
        delta_amt = int(delta_td / np.timedelta64(1, unit))
        random_vals = rng.integers(low=0, high=delta_amt, size=count, endpoint=True)
        random_dts = start_dt + random_vals.astype(f"timedelta64[{unit}]")
        dt_srs = pd.Series(random_dts)

        return [dt_srs.dt.strftime(dt_format)]

    return _generate


def to_data_frame(
    column_to_generator_dict: dict[Union[str, tuple[str, ...]], Generator],
    count: int,
) -> pd.DataFrame:
    """
    Generate data frame by using multiple generators at once.
    Column names must be mapped to their respective generators.
    A generator can be assigned to one or multiple column names, but it must always match the amount of series
    that the generator returns.

    Args:
        column_to_generator_dict: mapping of column names to generators
        count: amount of records to generate

    Returns:
        data frame with columns and rows generated as specified
    """
    if len(column_to_generator_dict) == 0:
        raise ValueError("generator dict may not be empty")

    if count <= 0:
        raise ValueError(f"amount of rows must be positive, is {count}")

    col_to_srs_dict: dict[str, pd.Series] = {}

    for gen_col_names, gen in column_to_generator_dict.items():
        # if a single string is provided, concat by wrapping it into a list
        if isinstance(gen_col_names, str):
            gen_col_names = (gen_col_names,)

        # generate values
        gen_col_values = gen(count)

        # check that the generator returned as many columns as expected
        if len(gen_col_values) != len(gen_col_names):
            raise ValueError(
                f"generator returned {len(gen_col_values)} columns, but requires {len(gen_col_names)} to "
                f"fill column(s) for: {','.join(gen_col_names)}"
            )

        # assign name to series
        for i in range(len(gen_col_values)):
            col_to_srs_dict[gen_col_names[i]] = gen_col_values[i]

    # finally create df from the list of named series
    return pd.DataFrame(data=col_to_srs_dict)
