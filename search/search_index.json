{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro to Gecko","text":"<p>Gecko is a Python library for mass generation and corruption of realistic synthetic data. It aims to be the bigger brother of the GeCo framework which was originally published by Tran et al. in 2013<sup>1</sup>.</p> <p>Gecko brings a lot of quality-of-life and performance improvements over its predecessor. It is backed by Numpy and Pandas which allows for easy integration into existing data science applications, as well as massively improved performance by leveraging their vectorized functions wherever possible.</p> <p>The aim of Gecko is to provide a library which allows for the creation of shareable Python scripts that generate reliable and reproducible synthetic datasets.</p>"},{"location":"#installation","title":"Installation","text":"<p>To get started, install Gecko using your preferred package management tool.</p> <p>With pip:</p> <pre><code>pip install gecko-syndata\n</code></pre> <p>With Poetry:</p> <pre><code>poetry add gecko-syndata\n</code></pre>"},{"location":"#overview","title":"Overview","text":"<p>Gecko consists of two modules: <code>generator</code> and <code>corruptor</code>. These modules are responsible for, as their name implies, generating and corrupting data respectively.</p> <p></p> Gecko library overview <p>A generator is any function that takes in a number of values to create and returns a list of series, where each series contains the desired amount of generated values. Generators are expressed by the following type alias.</p> <pre><code>from typing import Callable\nimport pandas as pd\n\n# Generator type definition.\nGenerator = Callable[[int], list[pd.Series]]\n\n# This is what a valid generator looks like.\ndef my_generator(count: int) -&gt; pd.Series:\n    pass\n</code></pre> <p>A corruptor is any function that takes in a list of series and returns a modified copy of it. Similar to generators, they are expressed with a simple type alias.</p> <pre><code>from typing import Callable\nimport pandas as pd\n\n# Corruptor type definition.\nCorruptor = Callable[[list[pd.Series]], list[pd.Series]]\n\n# This is what a valid corruptor looks like.\ndef my_corruptor(srs_lst: list[pd.Series]) -&gt; list[pd.Series]:\n    pass\n</code></pre> <p>The <code>generator</code> and <code>corruptor</code> modules provide functions to create generators and corruptors for a range of use cases. Gecko provides built-in functions to create generators based on frequency tables and numeric distributions, as well as corruptors based on keyboard maps, phonetic errors, edit errors and much more.</p> <p>You can freely define your own generators and corruptors, or have Gecko create wrappers around existing functions. There are also helper functions which allow you to chain multiple generators together to create one data frame and to apply multiple corruptors to a data frame at once. </p> <p>The remainder of this documentation provides a deep dive into the <code>generator</code> and <code>corruptor</code> modules. They showcase Gecko's built-in capabilities with plenty of examples.</p> <ol> <li> <p>See: Tran, K. N., Vatsalan, D., &amp; Christen, P. (2013, October). GeCo: an online personal data generator and corruptor. In Proceedings of the 22nd ACM international conference on Information &amp; Knowledge Management (pp. 2473-2476).\u00a0\u21a9</p> </li> </ol>"},{"location":"data-corruption/","title":"Corrupting data","text":"<p>Gecko comes with a lot of built-in functions that corrupt data by applying errors that one might find in the real world. Any function that takes in and returns a list of Pandas series is considered a corruptor function in Gecko.</p> <pre><code>import pandas as pd\n\ndef corruptor_func(srs_lst: list[pd.Series]) -&gt; list[pd.Series]:\n    assert len(srs_lst) == 1  # check amount of columns\n    srs_out = srs_lst[0].copy()\n    # ... perform mutations on the copy ...\n    return [srs_out]\n</code></pre> <p>Gecko provides functions for introducing typographic, phonetic and other errors. These functions are exposed in Gecko's <code>corruptor</code> module.</p>"},{"location":"data-corruption/#available-corruptors","title":"Available corruptors","text":""},{"location":"data-corruption/#keyboard-typos","title":"Keyboard typos","text":"<p>One of the most common sources for typos are adjacent keys on a keyboard. Gecko supports loading of keyboard layouts and applying typos based on them. Currently, keyboard layouts must be provided as an XML file from the Unicode CLDR repository. Gecko parses these files and determines all neighboring keys of each key, as well as their variants with and without Shift pressed.</p> <p>Warning</p> <p>As of Unicode CLDR keyboard specification is under a major redesign as of release 44. Support will be added as soon as the specification is finalized. For now, please retrieve CLDR keyboard files from a release tagged 43 or earlier. The examples in this documentation use files from the CLDR release 43.</p> <p>Download the German keyboard layout from the CLDR repository. The corresponding corruptor function is called <code>with_cldr_keymap_file</code>. Point the corruptor to the file you just downloaded. In the following example, one character in each word is substituted by another neighboring character on the German keyboard.</p> <pre><code>import pandas as pd\nimport numpy as np\n\nfrom gecko import corruptor\n\nrng = np.random.default_rng(3141)\nkb_corruptor = corruptor.with_cldr_keymap_file(\n    \"./de-t-k0-windows.xml\",\n    rng=rng\n)\nsrs = pd.Series([\"apple\", \"banana\", \"clementine\"])\nprint(kb_corruptor([srs]))\n# =&gt; [[\"spple\", \"banany\", \"cldmentine\"]]\n</code></pre> <p>By default, this corruptor considers all possible neighboring keys for each key. If you want to constrain typos to a certain set of characters, you can pass an optional string of characters to this corruptor. One such example is to limit the corruptor to digits when manipulating a series of numbers that are broken up by non-digit characters. The following snippet avoids the substitution of hyphens by specifying that only digits may be manipulated.</p> <pre><code>import pandas as pd\nimport numpy as np\nimport string\n\nfrom gecko import corruptor\n\nrng = np.random.default_rng(2718)\nkb_corruptor = corruptor.with_cldr_keymap_file(\n    \"./de-t-k0-windows.xml\",\n    charset=string.digits,\n    rng=rng\n)\nsrs = pd.Series([\"123-456-789\", \"727-727-727\", \"294-753-618\"])\nprint(kb_corruptor([srs]))\n# =&gt; [[\"122-456-789\", \"827-727-727\", \"294-753-628\"]]\n</code></pre>"},{"location":"data-corruption/#phonetic-errors","title":"Phonetic errors","text":"<p>One of the most challenging error sources to model are phonetic errors. These are words that sound the same but are written differently.</p> <p>In German, for example, \"\u00df\" can almost always be replaced with \"ss\" and still have the word that it's in sound the same. Whether one writes \"Stra\u00dfe\" or \"Strasse\" does not matter as far as pronunciation is concerned. The same holds for \"dt\" and \"tt\" at the end of a word, since both reflect a hard \"t\" sound. One can derive rules from similarly sounding character sequences.</p> <p>Gecko offers a method for modelling these rules and introducing phonetic errors based on them. A phonetic rule in Gecko consists of a source pattern (\"\u00df\", \"dt\"), a target pattern (\"ss\", \"tt\") and positional flags. The flags determine whether this rule applies at the start (<code>^</code>), in the middle (<code>_</code>) or the end (<code>$</code>) of a word. These flags can be freely combined. The absence of a positional flag implies that a rule can be applied anywhere in a string. Taking the example from above, a suitable rule table could look like this.</p> CSVTable <pre><code>source,target,flags\n\u00df,ss,\ndt,tt,$\n</code></pre> Source Target Flags \u00df ss dt tt $ <p>Gecko exposes the <code>with_phonetic_replacement_table</code> function to handle these types of tables. The signature is similar to that of <code>with_replacement_table</code>.</p> <pre><code>import numpy as np\nimport pandas as pd\n\nfrom gecko import corruptor\n\nrng = np.random.default_rng(8844167)\n\nphonetic_corruptor = corruptor.with_phonetic_replacement_table(\n    \"./phonetic-rules-de.csv\",\n    header=True,\n    source_column=\"source\",\n    target_column=\"target\",\n    flags_column=\"flags\",\n    rng=rng,\n)\n\nsrs = pd.Series([\"stra\u00dfe\", \"stadt\", \"schie\u00dfen\"])\nprint(phonetic_corruptor([srs]))\n# =&gt; [[\"strasse\", \"statt\", \"schiessen\"]]\n</code></pre>"},{"location":"data-corruption/#missing-values","title":"Missing values","text":"<p>A textual representation of a \"missing value\" is sometimes used to clearly indicate that a blank or an empty value is to be interpreted as a missing piece of information. In datasets sourced from large databases, this \"missing value\" might consist of characters that do not adhere to a table or column schema. A simple example would be <code>###_MISSING_###</code> in place of a person's date of birth, since it does not conform to any common date format and consists entirely of letters and special characters. </p> <p>Gecko provides the function <code>with_missing_value</code> which replaces certain values within a series with a custom \"missing value\". The corruptor replaces either empty, blank or all strings within a series depending on the defined strategy. This is best explained by a few examples.</p> <p>Gecko considers strings to be \"empty\" when their length is zero. Strings with whitespaces will be left as-is.</p> <pre><code>import pandas as pd\n\nfrom gecko import corruptor\n\nmissing_corruptor = corruptor.with_missing_value(\n    \"###_MISSING_###\", \n    strategy=\"empty\"\n)\nsrs = pd.Series([\"apple\", \"   \", \"\"])\nprint(missing_corruptor([srs]))\n# =&gt; [[\"apple\", \"   \", \"###_MISSING_###\"]]\n</code></pre> <p>Gecko considers strings to be \"blank\" when their length is zero after trimming all leading and trailing whitespaces. This is the default behavior of this corruptor.</p> <pre><code>import pandas as pd\n\nfrom gecko import corruptor\n\nmissing_corruptor = corruptor.with_missing_value(\n    \"###_MISSING_###\", \n    strategy=\"blank\"\n)\nsrs = pd.Series([\"apple\", \"   \", \"\"])\nprint(missing_corruptor([srs]))\n# =&gt; [[\"apple\", \"###_MISSING_###\", \"###_MISSING_###\"]]\n</code></pre> <p>The \"nuclear\" option is to replace all strings within a series with the \"missing value\".</p> <pre><code>import pandas as pd\n\nfrom gecko import corruptor\n\nmissing_corruptor = corruptor.with_missing_value(\n    \"###_MISSING_###\", \n    strategy=\"all\"\n)\nsrs = pd.Series([\"apple\", \"   \", \"\"])\nprint(missing_corruptor([srs]))\n# =&gt; [[\"###_MISSING_###\", \"###_MISSING_###\", \"###_MISSING_###\"]]\n</code></pre>"},{"location":"data-corruption/#edit-errors","title":"Edit errors","text":"<p>Edit errors are caused by a set of operations on single characters within a word. There are commonly four operations that can induce these types of errors: insertion and deletion of a single character, substitution of a character with a different one, and transposition of two adjacent characters.</p> <p>Gecko provides corruptors for each of these operations.  For insertions and substitutions, it is possible to define a set of characters to choose from.</p> <pre><code>import string\n\nimport numpy as np\nimport pandas as pd\n\nfrom gecko import corruptor\n\nrng = np.random.default_rng(8080)\nsrs = pd.Series([\"apple\", \"banana\", \"clementine\"])\n\ninsert_corruptor = corruptor.with_insert(charset=string.ascii_letters, rng=rng)\nprint(insert_corruptor([srs]))\n# =&gt; [[\"aVpple\", \"banaFna\", \"clemenMtine\"]]\n\ndelete_corruptor = corruptor.with_delete(rng=rng)\nprint(delete_corruptor([srs]))\n# =&gt; [[\"aple\", \"bnana\", \"clementin\"]]\n\nsubstitute_corruptor = corruptor.with_substitute(charset=string.digits, rng=rng)\nprint(substitute_corruptor([srs]))\n# =&gt; [[\"appl9\", \"ba4ana\", \"clementi9e\"]]\n\ntranspose_corruptor = corruptor.with_transpose(rng)\nprint(transpose_corruptor([srs]))\n# =&gt; [[\"paple\", \"baanna\", \"clemenitne\"]]\n</code></pre> <p>Gecko also provides a more general edit corruptor which wraps around the insertion, deletion, substitution and transposition corruptor. It is then possible to assign probabilities for each operation. By default, all operations are equally likely to be performed.</p> <pre><code>import numpy as np\nimport pandas as pd\n\nfrom gecko import corruptor\n\nrng = np.random.default_rng(8443)\nsrs = pd.Series([\"apple\", \"banana\", \"clementine\", \"durian\", \"eggplant\", \"fig\", \"grape\", \"honeydew\"])\n\nedit_corruptor_1 = corruptor.with_edit(rng=rng)\nprint(edit_corruptor_1([srs]))\n# =&gt; [[\"aple\", \"banan\", \"clementinb\", \"duiran\", \"eAgplant\", \"Nig\", \"grapce\", \"hoKeydew\"]]\n\nedit_corruptor_2 = corruptor.with_edit(\n    p_insert=0.1,\n    p_delete=0.2,\n    p_substitute=0.3,\n    p_transpose=0.4,\n    rng=rng,\n)\nprint(edit_corruptor_2([srs]))\n# =&gt; [[\"aplpe\", \"anana\", \"lementine\", \"duriRan\", \"geggplant\", \"fg\", \"rgape\", \"honedyew\"]]\n</code></pre>"},{"location":"data-corruption/#categorical-errors","title":"Categorical errors","text":"<p>Sometimes an attribute can only take on a set number of values. For example, if you have a \"gender\" column in your dataset and it can only take on <code>m</code> for male, <code>f</code> for female and <code>o</code> for other, it wouldn't make sense for a corrupted record to contain anything else except these three options.</p> <p>Gecko offers the <code>with_categorical_values</code> function for this purpose. It sources all possible options from a column in CSV file and then applies random replacements respecting the limited available options.</p> <pre><code>import numpy as np\nimport pandas as pd\n\nfrom gecko import corruptor\n\nrng = np.random.default_rng(22)\nsrs = pd.Series([\"f\", \"m\", \"f\", \"f\", \"o\", \"m\", \"o\", \"o\"])\n\ncategorical_corruptor = corruptor.with_categorical_values(\n    \"./gender.csv\",  # CSV file containing \"gender\" column with \"f\", \"m\" and \"o\" as possible values\n    header=True,\n    value_column=\"gender\",\n    rng=rng,\n)\n\nprint(categorical_corruptor([srs]))\n# =&gt; [[\"o\", \"f\", \"m\", \"o\", \"f\", \"o\", \"f\", \"m\"]]\n</code></pre>"},{"location":"data-corruption/#value-permutations","title":"Value permutations","text":"<p>Certain types of information are easily confused with others. This is particularly true for names, where the differentiation between given and last names in a non-native language is challenging to get right. The <code>with_permute</code> function handles this exact use case. It simply swaps the values of two series that are passed into it.</p> <pre><code>import pandas as pd\n\nfrom gecko import corruptor\n\nsrs_given_name = pd.Series([\"Max\", \"Jane\", \"Jan\"])\nsrs_last_name = pd.Series([\"Mustermann\", \"Doe\", \"Jansen\"])\n\npermute_corruptor = corruptor.with_permute()\nprint(permute_corruptor([srs_given_name, srs_last_name]))\n# =&gt; [[\"Mustermann\", \"Doe\", \"Jansen\"],\n#       [\"Max\", \"Jane\", \"Jan\"]]\n</code></pre>"},{"location":"data-corruption/#common-replacements","title":"Common replacements","text":"<p>Other various error sources, such as optical character recognition (OCR) errors, can be modeled using simple replacement tables. These tables have a source and a target column, defining mappings between character sequences.</p> <p>The <code>with_replacement_table</code> function achieves just that. Suppose you have the following CSV file with common OCR errors.</p> <pre><code>k,lc\n5,s\n2,z\n1,|\n</code></pre> <p>You can use this file the same way you can with many other generation and corruption functions in Gecko.</p> <pre><code>import numpy as np\nimport pandas as pd\n\nfrom gecko import corruptor\n\nrng = np.random.default_rng(6379)\nsrs = pd.Series([\"kick 0\", \"step 1\", \"go 2\", \"run 5\"])\n\nreplacement_corruptor = corruptor.with_replacement_table(\n    \"./ocr.csv\",\n    rng=rng,\n)\n\nprint(replacement_corruptor([srs]))\n# =&gt; [\"lcick 0\", \"step |\", \"go z\", \"run s\"]\n</code></pre>"},{"location":"data-corruption/#multiple-corruptors","title":"Multiple corruptors","text":"<p>Using <code>corrupt_dataframe</code>, you can apply multiple corruptors on many columns at once. It is possible to set probabilities for each corruptor, as well as to define multiple corruptors per column.</p> <pre><code>import string\n\nimport numpy as np\nimport pandas as pd\n\nfrom gecko import corruptor\nfrom gecko.corruptor import with_permute\n\ndf = pd.DataFrame(\n    {\n        \"fruit\": [\"apple\", \"banana\", \"orange\"],\n        \"type\": [\"elstar\", \"cavendish\", \"mandarin\"],\n        \"weight_in_grams\": [\"241.0\", \"195.6\", \"71.1\"],\n        \"amount\": [\"3\", \"5\", \"6\"],\n        \"grade\": [\"B\", \"C\", \"B\"],\n    }\n)\n\nrng = np.random.default_rng(25565)\n\ndf_corrupt = corruptor.corrupt_dataframe(df, {\n    (\"fruit\", \"type\"): (.5, with_permute()),  # (1)!\n    \"grade\": [  # (2)!\n        corruptor.with_missing_value(strategy=\"all\"),\n        corruptor.with_substitute(charset=string.ascii_uppercase, rng=rng),\n    ],\n    \"amount\": [  # (3)!\n        (.8, corruptor.with_insert(charset=string.digits, rng=rng, )),\n        (.2, corruptor.with_delete(rng=rng, ))\n    ]\n}, rng=rng)\n\nprint(df_corrupt)\n# =&gt; [[\"fruit\", \"type\", \"weight_in_grams\", \"amount\", \"grade\"],\n#       [\"apple\", \"elstar\", \"241.0\", \"83\", \"\"],\n#       [\"cavendish\", \"banana\", \"195.6\", \"\", \"O\"],\n#       [\"mandarin\", \"orange\", \"71.1\", \"\", \"F\"]]\n</code></pre> <ol> <li>You can assign probabilities to a corruptor for a column. In this case, the permutation corruptor will be applied to 50% of all records. The remaining 50% remain untouched.</li> <li>You can assign multiple corruptors to a column. In this case, the two corruptors will be evenly applied to 50% of all records.</li> <li>You can assign probabilities to multiple corruptors for a column. In this case, the insertion and deletion corruptor are applied to 80% and 20% of all records respectively.</li> </ol>"},{"location":"data-generation/","title":"Generating data","text":"<p>Any function that takes in a number of rows and returns a list of Pandas series is considered a generator function in Gecko.</p> <pre><code>import pandas as pd\n\ndef generator_func(count: int) -&gt; list[pd.Series]:\n    # this is where data generation magic would happen ...  \n    return [pd.Series([str(i) for i in range(count)])]\n</code></pre>"},{"location":"data-generation/#available-generators","title":"Available generators","text":""},{"location":"data-generation/#frequency-tables","title":"Frequency tables","text":"<p>One of the most common sources to generate realistic-looking data are frequency tables. Gecko supports loading frequency tables from CSV files and generating data based off frequencies listed within.</p> <p>Assume a CSV file containing a list of fruits and their frequencies. The goal is to generate a series that has a similar distribution of values.</p> CSVTable <pre><code>fruit,count\napple,100\nbanana,50\norange,80\n</code></pre> Fruit Count Apple 100 Banana 50 Orange 80 <p>Gecko exposes the function <code>from_frequency_table</code> for this purpose. Point the generator to the CSV file. It requires some additional information in order to correctly read the CSV file. Since it contains a header with column names, the <code>header</code> argument needs to be set to <code>True</code>. Furthermore, since the columns are named, the value and frequency columns need to be explicitly passed in too.</p> <pre><code>import numpy as np\n\nfrom gecko import generator\n\nrng = np.random.default_rng(112358)\nfruit_generator = generator.from_frequency_table(\n    \"fruit.csv\",\n    header=True,\n    value_column=\"fruit\",\n    frequency_column=\"count\",\n    rng=rng\n)\n\nprint(fruit_generator(1000))\n# =&gt; [[\"orange\", \"apple\", \"apple\", \"banana\", ..., \"apple\", \"apple\"]]\n</code></pre>"},{"location":"data-generation/#multi-column-frequency-tables","title":"Multi-column frequency tables","text":"<p>Oftentimes, frequencies do not depend on a single variable. For this purpose, Gecko can generate values based off of multiple columns within a CSV file.</p> <p>Continuing the example from above, assume a frequency table with fruits and their types.</p> CSVTable <pre><code>fruit,type,count\napple,braeburn,30\napple,elstar,70\nbanana,cavendish,40\nbanana,plantain,10\norange,clementine,55\norange,mandarin,25\n</code></pre> Fruit Type Count Apple Braeburn 30 Apple Elstar 70 Banana Cavendish 40 Banana Plantain 10 Orange Clementine 55 Orange Mandarin 25 <p>These types of frequency tables are handled by the <code>from_multicolumn_frequency_table</code> function. The syntax is similar to that of <code>from_frequency_table</code>, except multiple value columns can be passed into it. This results in a list of series; one for each value column passed into the generator.</p> <pre><code>import numpy as np\n\nfrom gecko import generator\n\nrng = np.random.default_rng(14916)\nfruit_generator = generator.from_multicolumn_frequency_table(\n    \"./fruit-types.csv\",\n    header=True,\n    value_columns=[\"fruit\", \"type\"],\n    freq_column=\"count\",\n    rng=rng,\n)\n\nprint(fruit_generator(1000))\n# =&gt; [[\"banana\", \"orange\", \"apple\", \"orange\", ..., \"orange\", \"banana\"],\n#     [\"cavendish\", \"mandarin\", \"elstar\", \"clementine\", ..., \"mandarin\", \"cavendish\"]]\n</code></pre>"},{"location":"data-generation/#numeric-distributions","title":"Numeric distributions","text":"<p>Gecko provides functions to sample random numbers from uniform and normal distributions. These are exposed using the <code>from_uniform_distribution</code> and <code>from_normal_distribution</code> functions. The numbers are formatted into strings, where the amount of decimal places can be passed to the generators.</p> <p>The generator for uniform distributions requires an inclusive lower bound and an exclusive upper bound.</p> <pre><code>import numpy as np\n\nfrom gecko import generator\n\nrng = np.random.default_rng(2357)\nuniform_generator = generator.from_uniform_distribution(\n    low=40, high=80, precision=2, rng=rng\n)\n\nprint(uniform_generator(100))\n# =&gt; [[47.71, 77.53, 54.93, 50.04, ..., 51.69, 65.63]]\n</code></pre> <p>The generator for normal distributions requires a mean and a standard deviation.</p> <pre><code>import numpy as np\n\nfrom gecko import generator\n\nrng = np.random.default_rng(3731)\nnormal_generator = generator.from_normal_distribution(\n    mean=22, sd=3, precision=2, rng=rng\n)\n\nprint(normal_generator(100))\n# =&gt; [[23.77, 17.13, 22.08, 22.07, ..., 21.10, 22.67]]\n</code></pre>"},{"location":"data-generation/#custom-generators","title":"Custom generators","text":"<p>Any function that returns a string can be converted into a generator. Gecko provides <code>from_function</code> as a wrapper around such functions.</p> <p>Warning</p> <p>You should not use <code>from_function</code> if performance matters. All built-in generators provided by Gecko are optimized to generate many values at once. With <code>from_function</code>, new values are generated one by one.</p> <p>Arguments taken by the wrapped function must be passed to <code>from_function</code>. These arguments are then passed on when values are being generated. Take the following snippet for example, which generates a random sequence of letters.</p> <pre><code>import numpy as np\nimport string\n\nfrom gecko import generator\n\ndef next_letter(\n    my_rng: np.random.Generator,\n    charset: str = string.ascii_lowercase\n):\n    return my_rng.choice(list(charset))\n\nrng = np.random.default_rng(11247)\n\nmy_generator = generator.from_function(\n    next_letter, \n    my_rng=rng\n)\nprint(my_generator(100))\n# =&gt; [[\"e\", \"m\", \"e\", \"y\", ..., \"u\", \"h\"]]\n\nmy_umlaut_generator = generator.from_function(\n    next_letter, \n    my_rng=rng, \n    charset=\"\u00e4\u00f6\u00fc\"\n)\nprint(my_umlaut_generator(100))\n# =&gt; [[\"\u00fc\", \"\u00fc\", \"\u00fc\", \"\u00e4\", ..., \"\u00e4\", \"\u00e4\"]]\n</code></pre> <p>An interesting use case is to use Gecko in combination with the popular Faker library. Faker offers many providers for generating synthetic data. All providers that return strings can be plugged seamlessly into Geckos <code>from_function</code> generator. However, users of Faker are responsible for seeding their own RNG instances to achieve reproducible results.</p> <pre><code>from faker import Faker\nfrom geco import generator\n\nfake = Faker(\"de_DE\")\nfake.seed_instance(13579)\n\nfirst_name_generator = generator.from_function(fake.first_name)\nage_generator = generator.from_function(\n    fake.date_of_birth,\n    minimum_age=18,\n    maximum_age=80,\n)\n\nprint(first_name_generator(100))\n# =&gt; [[\"Jurij\", \"Andy\", \"Gundolf\", \"Gordana\", ..., \"Ismet\", \"Annegrete\"]]\nprint(age_generator(100))\n# =&gt; [[\"1969-09-12\", \"1971-12-15\", \"1985-03-10\", \"1949-06-18\", ..., \"1956-07-26\", \"1964-09-26\"]]\n</code></pre>"},{"location":"data-generation/#multiple-generators","title":"Multiple generators","text":"<p>All generators return one or more series, so it is reasonable to combine them all together into one Pandas data frame for further processing. Gecko provides the <code>to_dataframe</code> function which takes in a list of generators and column names and generates a data frame based on them. The following example utilizes most of the generators shown in this guide.</p> <pre><code>import numpy as np\n\nfrom gecko import generator\n\nrng = np.random.default_rng(222)\n\nfruit_generator = generator.from_multicolumn_frequency_table(\n    \"./fruit-types.csv\",\n    header=True,\n    value_columns=[\"fruit\", \"type\"],\n    freq_column=\"count\",\n    rng=rng,\n)\n\nweight_generator = generator.from_normal_distribution(\n    mean=150,\n    sd=50,\n    precision=1,\n    rng=rng,\n)\n\namount_generator = generator.from_uniform_distribution(\n    2,\n    8,\n    precision=0,\n    rng=rng,\n)\n\ndef next_fruit_grade(rand: np.random.Generator) -&gt; str:\n    return rand.choice(list(\"ABC\"))\n\ngrade_generator = generator.from_function(\n    next_fruit_grade,\n    rand=rng,\n)\n\ndf = generator.to_dataframe(\n    {\n        (\"fruit\", \"type\"): fruit_generator,\n        \"weight_in_grams\": weight_generator,\n        \"amount\": amount_generator,\n        \"grade\": grade_generator,\n    },\n    1000,\n)\n\nprint(df)\n# =&gt; [[\"fruit\", \"type\", \"weight_in_grams\", \"amount\", \"grade\"],\n#       [\"apple\", \"elstar\", \"162.5\", \"8\", \"C\"],\n#       [\"orange\", \"clementine\", \"186.8\", \"5\", \"A\"],\n#       ...,\n#       [\"apple\", \"elstar\", \"78.7\", \"4\", \"B\"]]\n</code></pre>"},{"location":"release-notes/","title":"Release notes","text":""},{"location":"release-notes/#020-feb-16-2024","title":"0.2.0 (Feb 16, 2024)","text":""},{"location":"release-notes/#features","title":"Features","text":"<ul> <li>Add <code>generator.with_permute</code> for swapping values between series</li> <li>Set wider version ranges for dependencies</li> <li>Fix <code>corruptor.corrupt_dataframe</code> to not modify original data frame</li> <li>Add tests to all corruptor functions to ensure no modifications to original data</li> </ul>"},{"location":"release-notes/#refactors","title":"Refactors","text":"<ul> <li>Change generators to take in and return a list of series instead of single series</li> <li>Change <code>generator.to_dataframe</code> signature to align with <code>corruptor.corrupt_dataframe</code></li> </ul>"},{"location":"release-notes/#internal","title":"Internal","text":"<ul> <li>Extend CI pipeline with a benchmarking step that runs on release and when manually triggered</li> <li>Add benchmark based on the \"fruits\" example in the docs</li> </ul>"},{"location":"release-notes/#010-feb-8-2024","title":"0.1.0 (Feb 8, 2024)","text":"<ul> <li>Initial release</li> </ul>"},{"location":"examples/german/","title":"Example: German population dataset","text":"<p>In this example, you will create a script that generates and corrupts a dataset of German persons. To get started, create a new directory for your project. Within it, create an empty <code>main.py</code> file. Install Gecko and obtain a copy of the Gecko data repository. If you have Git installed, you can simply clone it into your project directory with the following command.</p> <pre><code>git clone https://gitlab.com/ul-mds/record-linkage/gecko/gecko-data.git\n</code></pre> <p>Your project directory should look something like this:</p> <pre><code>|- gecko-data/\n|- main.py\n|- poetry.lock       (only if you use Poetry)\n|- pyproject.toml    (only if you use Poetry)\n</code></pre> <p>The Gecko data repository contains mostly CSV files which have been generated from publicly available datasets. It is a decent starting point if you just want to explore Gecko's capabilities.</p>"},{"location":"examples/german/#setting-up-the-script","title":"Setting up the script","text":"<p>To get started, edit your <code>main.py</code> and import Numpy, Pandas and Gecko's generator and corruptor module. Numpy is needed to create a random number generator (RNG) with a fixed starting point so that the generated data remains consistent across script executions. Most modern code editors should be able to make use of that.</p> <pre><code>import numpy as np # (1)!\n\nfrom gecko import generator, corruptor\n\nif __name__ == \"__main__\": # (2)!\n    rng = np.random.default_rng(727) # (3)!\n</code></pre> <ol> <li>Numpy is imported to make use of its random number generator (RNG). Numpy's RNG functions are extensively used in Gecko's built-in generators and corruptors.</li> <li>This is standard Python boilerplate code. All code in this block is executed when the script is explicitly run using <code>python main.py</code>.</li> <li>This line creates a new RNG with a fixed starting point. You can choose any number you want here. Go crazy!</li> </ol> <p>Tip: Click on the  icon in the code snippets to get extra info on what a line of code does.</p> <p>Next, add two functions to your script. <code>generate_data_frame</code> takes in a number of records to generate and a RNG. For now this function is empty, but when it's complete, it will return a data frame with the desired amount of rows. <code>corrupt_data_frame</code> takes in a data frame and a RNG and returns a modified copy of the data frame that is passed into it.</p> <p>Add two lines to your main code block to call the functions that you just created. Set the amount of records to any number you want. In this example, the aim is to generate 100k records.</p> <pre><code>import numpy as np\n\nfrom gecko import generator, corruptor\n\n\ndef generate_data_frame(count, rng): # (1)!\n    pass\n\n\ndef corrupt_data_frame(df, rng): # (2)!\n    pass\n\n\nif __name__ == \"__main__\":\n    rng = np.random.default_rng(727)\n    df_original = generate_data_frame(100000, rng) # (3)!\n    df_corrupted = corrupt_data_frame(df_original, rng)\n</code></pre> <ol> <li>Once complete, this function will generate a data frame with synthetic data. The amount of rows is set with the <code>count</code> parameter. Data frames are, in essence, Pandas' representation of two-dimensional tabular data.</li> <li>Once complete, this function will corrupt the data frame that is passed into it and return the corrupted copy. <code>df</code> is a common shorthand for \"data frame\".</li> <li>Gecko works with Pandas data types. If you are familiar with Pandas, you will find working with the results generated by Gecko to be easy. A few use cases will be demonstrated later in this example.</li> </ol>"},{"location":"examples/german/#generating-data","title":"Generating data","text":"<p>Now it's finally time to synthesize some data. The Gecko data repository contains a CSV file for the most common last names found in Germany. It consists of two columns: <code>last_name</code> and <code>count</code>. To use it with Gecko, use the <code>from_frequency_table</code> function from the <code>generator</code> module. Since the CSV file contains a header, some extra configuration is necessary.</p> <pre><code>def generate_data_frame(count, rng): # (1)!\n    gen_last_name = generator.from_frequency_table(\n        \"gecko-data/de_DE/last-name.csv\",  # (2)!\n        header=True,  # (3)!\n        value_column=\"last_name\",  # (4)!\n        freq_column=\"count\",  # (5)!\n        rng=rng,  # (6)!\n    )\n</code></pre> <ol> <li>For brevity, the rest of the script is excluded from this snippet. Bear in mind that all code you write belongs in your <code>main.py</code> file.</li> <li>This is the path to the CSV file. It's relative to the location of the <code>main.py</code> file.</li> <li>Since Gecko does not consider header lines in CSV files by default, you need to explicitly tell it to treat the first line in the CSV file as a header.</li> <li>This is the name of the column in the CSV file that contains the values to generate.</li> <li>This is the name of the column in the CSV file that contains the absolute frequency per value.</li> <li>Almost every function in Gecko allows for a RNG to be passed in. Reusing the same RNG in your script is crucial to ensure reproducibility. If no RNG is passed in, Gecko will use a new RNG with a random starting point.</li> </ol> <p>Last names aren't everything though. Next to last names, the Gecko data repository provides a CSV file with given names, as well as a gender code to state whether a given name is more predominantly assigned to males or females.</p> <p>This highlights an important aspect about generating realistic synthetic data. Even though data in the real world might seem random, it rarely is. Names depend on gender at birth, ethnicity, trends in baby names over time and many other social factors. Gecko provides the tools to generate data according to these complex dependencies. Since this is an entry-level example, we will keep it as simple as possible. But if you start to curate your own data sources for use with Gecko, keep in mind that more variables make for a more realistic dataset.</p> <p>To generate data from CSV files with multiple interdependent columns, use Gecko's <code>from_multicolumn_frequency_table</code> function. Its syntax is almost the same as <code>from_frequency_table</code>, except it allows for multiple value columns to be specified.</p> <pre><code>def generate_data_frame(count, rng): \n    gen_last_name = generator.from_frequency_table(\n        \"gecko-data/de_DE/last-name.csv\", \n        header=True,  \n        value_column=\"last_name\",\n        freq_column=\"count\",\n        rng=rng,\n    )\n\n    gen_given_name_gender = generator.from_multicolumn_frequency_table(\n        \"gecko-data/de_DE/given-name-gender.csv\",\n        header=True,\n        value_columns=[\"given_name\", \"gender\"],  # (1)!\n        freq_column=\"count\",\n        rng=rng,\n    )\n</code></pre> <ol> <li>Note how this function accepts multiple column names. The generator will use this information to generate multiple columns at once.</li> </ol> <p>Gecko can provide generators that create one or two columns at a time, but can it do more than that? Of course. There are technically no limits to the amount of interdependent data it can generate ... except the computational and memory constraints of your machine. So let's add one more complex generator.</p> <p>The Gecko data repository has a CSV file with a non-exhaustive list of street names in Germany. As stated previously, street names are not random just like every other piece of personal information, so the file also lists the municipalities and post codes where each street can be found. Again, use <code>from_multicolumn_frequency_table</code> and pass in the corresponding column names to generate data from.</p> <pre><code>def generate_data_frame(count, rng): \n    gen_last_name = generator.from_frequency_table(\n        \"gecko-data/de_DE/last-name.csv\", \n        header=True,  \n        value_column=\"last_name\",\n        freq_column=\"count\",\n        rng=rng,\n    )\n\n    gen_given_name_gender = generator.from_multicolumn_frequency_table(\n        \"gecko-data/de_DE/given-name-gender.csv\",\n        header=True,\n        value_columns=[\"given_name\", \"gender\"],\n        freq_column=\"count\",\n        rng=rng,\n    )\n\n    gen_street_municip_postcode = generator.from_multicolumn_frequency_table(\n        \"gecko-data/de_DE/street-municipality-postcode.csv\",\n        header=True,\n        value_columns=[\"street_name\", \"municipality\", \"postcode\"],  # (1)!\n        freq_column=\"count\",\n        rng=rng,\n    )\n</code></pre> <ol> <li>Gecko can work with any amount of value columns, as long as your machine allows for the generation of all that data, of course.</li> </ol> <p>To tie it all together, Gecko offers the <code>to_dataframe</code> function. Pass it a list of generators and the column names for each generator and Gecko will generate a data frame according to your specification.</p> <pre><code>def generate_data_frame(count, rng): \n    gen_last_name = generator.from_frequency_table(\n        \"gecko-data/de_DE/last-name.csv\", \n        header=True,  \n        value_column=\"last_name\",\n        freq_column=\"count\",\n        rng=rng,\n    )\n\n    gen_given_name_gender = generator.from_multicolumn_frequency_table(\n        \"gecko-data/de_DE/given-name-gender.csv\",\n        header=True,\n        value_columns=[\"given_name\", \"gender\"],\n        freq_column=\"count\",\n        rng=rng,\n    )\n\n    gen_street_municip_postcode = generator.from_multicolumn_frequency_table(\n        \"gecko-data/de_DE/street-municipality-postcode.csv\",\n        header=True,\n        value_columns=[\"street_name\", \"municipality\", \"postcode\"], \n        freq_column=\"count\",\n        rng=rng,\n    )\n\n    return generator.to_dataframe({\n        (\"given_name\", \"gender\"): gen_given_name_gender,\n        \"last_name\": gen_last_name,\n        (\"street_name\", \"municipality\", \"postcode\"): gen_street_municip_postcode,\n    }, count)\n</code></pre> <ol> <li>The <code>to_dataframe</code> function takes two arguments: a list of generators and column names, and the number of records to generate.</li> <li>You must provide one or multiple column names for each generator, depending on how many columns a generator creates.</li> <li>If a generator returns only a single column, you can provide a single string. Otherwise, you must provide a list of strings.</li> </ol>"},{"location":"examples/german/#corrupting-data","title":"Corrupting data","text":"<p>Now that we have a data frame with lots of synthetic data, we can corrupt it. Gecko's <code>corruptor</code> module exposes the <code>corrupt_dataframe</code> function which allows you to apply any number of corruptors on the columns of a data frame.</p> <p>A common source of errors in a dataset are optical character recognition (OCR) errors. This happens when a physical document is scanned into an image and an OCR software attempts to extract its textual contents. The Gecko data repository contains a file with common OCR errors which, in fact, has been sourced straight from the original GeCo framework which inspired Gecko.</p> <p>To perform random inline replacements of letters within a word, use the <code>with_replacement_table</code> function from the <code>corruptor</code> module. Since the CSV file does not contain a header, there is nothing else that needs to be configured. If the CSV file were to have a header, you'd have to call it similar to the frequency table functions in the section on generating data. For this example, apply the corruptor to 10% of all values in the <code>given_name</code> column. </p> <pre><code>def corrupt_data_frame(df, rng):\n    return corruptor.corrupt_dataframe(df, {  # (1)!\n        \"given_name\": [\n            (0.1, corruptor.with_replacement_table(  # (2)!\n                \"gecko-data/common/ocr.csv\",\n                rng=rng,\n            ))\n        ]\n    }, rng=rng)  # (3)!\n</code></pre> <ol> <li>The <code>corrupt_dataframe</code> function takes in two arguments: the data frame to corrupt and a dictionary. This dictionary maps column names to a list of corruptors to apply to this column.</li> <li>Each column is assigned a list. This list contains entries that define how corruptors should be applied. The syntax for each entry is <code>(probability, corruptor)</code>. So in this case, the replacement table corruptor is applied to 10% of all values in the <code>given_name</code> column. The remaining 90% remain untouched.</li> <li>It is important to supply the RNG to <code>corrupt_dataframe</code> so that it always selectes the same records for corruption every time the script is run.</li> </ol> <p>For columns such as <code>gender</code>, the available options are limited. In this example, it can only take on the values <code>m</code> and <code>f</code>. Replacing it with anything else wouldn't make a lot of sense.</p> <p>Columns with a limited set of permitted values can be corrupted using the <code>with_categorical_values</code> function. This ensures that values within this column are only replaced with another valid value. You can reuse the CSV file containing given names and gender codes for this purpose. Point the corruptor to the <code>gender</code> column, and it'll automatically pick out all unique values within it. For this example, the corruptor should modify 2% of all rows.</p> <pre><code>def corrupt_data_frame(df, rng):\n    return corruptor.corrupt_dataframe(df, { \n        \"given_name\": [\n            (0.1, corruptor.with_replacement_table(\n                \"gecko-data/common/ocr.csv\",\n                rng=rng,\n            ))\n        ],\n        \"gender\": [\n            (0.02, corruptor.with_categorical_values(  # (1)!\n                \"gecko-data/de_DE/given-name-gender.csv\",\n                header=True,\n                value_column=\"gender\",\n                rng=rng,\n            ))\n        ]\n    }, rng=rng)\n</code></pre> <ol> <li>The <code>with_categorical_values</code> function allows you to reuse the same files that you used to generate your data. The function call is similar to the frequency table functions in the <code>generator</code> module.</li> </ol> <p>So far all you've done is apply a single corruptor to a column, but Gecko allows you to apply as many corruptors as you want to a column. Let's suppose that a few entries in the <code>gender</code> column are supposed to be missing. The <code>with_missing_value</code> function handles this exact use case. It replaces values with a representative \"missing value\", which is an empty string by default. Extend the list of corruptors for the <code>gender</code> column by applying the missing value corruptor to 5% of all records.</p> <pre><code>def corrupt_data_frame(df, rng):\n    return corruptor.corrupt_dataframe(df, { \n        \"given_name\": [\n            (0.1, corruptor.with_replacement_table(\n                \"gecko-data/common/ocr.csv\",\n                rng=rng,\n            ))\n        ],\n        \"gender\": [\n            (0.02, corruptor.with_categorical_values(\n                \"gecko-data/de_DE/given-name-gender.csv\",\n                header=True,\n                value_column=\"gender\",\n                rng=rng,\n            )),\n            (0.05, corruptor.with_missing_value(\n                value=\"\",  # (1)!\n                strategy=\"all\",  # (2)!\n            ))\n        ]\n    }, rng=rng)\n</code></pre> <ol> <li>By default, this corruptor uses an empty string as the \"missing value\". You don't need to add this parameter if you are happy with empty strings, but it's good practice nonetheless to be as explicit as possible in case the default value changes in the future.</li> <li>By setting the corruptor's strategy to <code>all</code>, it ensures that all of the randomly selected records will have their values replaced with an empty string. The other options, <code>blank</code> and <code>empty</code>, are explained in the documentation on corrupting data.</li> </ol> <p>Another common source of errors are typos on a keyboard. Gecko can read keymaps from the Unicode Common Locale Data Repository (CLDR) and apply typos based on them. Download the German CLDR keymap and place it next to your <code>main.py</code> script.</p> <p>We'll focus on the <code>postcode</code> column this time and assume that someone might slip with their finger during data entry and enter a wrong digit from time to time. The number row on the German keyboard is surrounded by many keys that don't generate digits. The <code>with_cldr_keymap_file</code> function accounts for that, granted that you pass it a string of allowed characters.</p> <pre><code>def corrupt_data_frame(df, rng):\n    return corruptor.corrupt_dataframe(df, { \n        \"given_name\": [\n            (0.1, corruptor.with_replacement_table(\n                \"gecko-data/common/ocr.csv\",\n                rng=rng,\n            ))\n        ],\n        \"gender\": [\n            (0.02, corruptor.with_categorical_values(\n                \"gecko-data/de_DE/given-name-gender.csv\",\n                header=True,\n                value_column=\"gender\",\n                rng=rng,\n            )),\n            (0.05, corruptor.with_missing_value(\n                value=\"\", \n                strategy=\"all\",\n            ))\n        ],\n        \"postcode\": [\n            (0.01, corruptor.with_cldr_keymap_file(\n                \"de-t-k0-windows.xml\",  # (1)!\n                charset=\"0123456789\",  # (2)!\n                rng=rng,\n            ))\n        ]\n    }, rng=rng)\n</code></pre> <ol> <li>The <code>with_cldr_keymap_file</code> function can read any CLDR keymap. Beware of limitations however since CLDR keymaps are currently undergoing a large revision.</li> <li>By constraining the corruptor this way, digits on the German keyboard can only be replaced with neighboring digits.</li> </ol>"},{"location":"examples/german/#putting-it-all-together","title":"Putting it all together","text":"<p>It's done! Well, for now at least.</p> <p>Gecko provides many more functions for generating and corrupting synthetic data. This example is a primer to show you the ropes. Feel free to extend this basic example with your own generators and corruptors.</p> <p>To wrap things up, export the original and corrupted data frames into their own CSV files. You can use Pandas' <code>to_csv</code> function to accomplish this. Your final script should look something like this.</p> <pre><code>import numpy as np\n\nfrom gecko import generator, corruptor\n\n\ndef generate_data_frame(count, rng): \n    gen_last_name = generator.from_frequency_table(\n        \"gecko-data/de_DE/last-name.csv\", \n        header=True,  \n        value_column=\"last_name\",\n        freq_column=\"count\",\n        rng=rng,\n    )\n\n    gen_given_name_gender = generator.from_multicolumn_frequency_table(\n        \"gecko-data/de_DE/given-name-gender.csv\",\n        header=True,\n        value_columns=[\"given_name\", \"gender\"],\n        freq_column=\"count\",\n        rng=rng,\n    )\n\n    gen_street_municip_postcode = generator.from_multicolumn_frequency_table(\n        \"gecko-data/de_DE/street-municipality-postcode.csv\",\n        header=True,\n        value_columns=[\"street_name\", \"municipality\", \"postcode\"], \n        freq_column=\"count\",\n        rng=rng,\n    )\n\n    return generator.to_dataframe({\n        (\"given_name\", \"gender\"): gen_given_name_gender,\n        \"last_name\": gen_last_name,\n        (\"street_name\", \"municipality\", \"postcode\"): gen_street_municip_postcode,\n    }, count)\n\n\ndef corrupt_data_frame(df, rng):\n    return corruptor.corrupt_dataframe(df, { \n        \"given_name\": [\n            (0.1, corruptor.with_replacement_table(\n                \"gecko-data/common/ocr.csv\",\n                rng=rng,\n            ))\n        ],\n        \"gender\": [\n            (0.02, corruptor.with_categorical_values(\n                \"gecko-data/de_DE/given-name-gender.csv\",\n                header=True,\n                value_column=\"gender\",\n                rng=rng,\n            )),\n            (0.05, corruptor.with_missing_value(\n                value=\"\", \n                strategy=\"all\",\n            ))\n        ],\n        \"postcode\": [\n            (0.01, corruptor.with_cldr_keymap_file(\n                \"de-t-k0-windows.xml\",  \n                charset=\"0123456789\",  \n                rng=rng,\n            ))\n        ]\n    }, rng=rng)\n\n\nif __name__ == \"__main__\":\n    rng = np.random.default_rng(727)\n    df_original = generate_data_frame(100000, rng)\n    df_corrupted = corrupt_data_frame(df_original, rng)\n    df_original.to_csv(\"german-original.csv\", index_label=\"id\")  # (1)!\n    df_corrupted.to_csv(\"german-corrupted.csv\", index_label=\"id\")\n</code></pre> <ol> <li>This highlights one of the main reasons why Gecko works on Pandas data types. It facilitates the inclusion into regular data science applications. You can use all your knowledge of Pandas on the results that Gecko provides to you.</li> </ol> <p>All that's left to do is to run <code>python main.py</code> and examine the fruits of your labor.</p>"},{"location":"examples/german/#bonus-writing-your-own-generator","title":"Bonus: Writing your own generator","text":"<p>Gecko comes with a lot of built-in functions, but you are free to write your own generators. Remember: a generator is a function that takes in a number of records and returns a list of Pandas series. As long as your custom function abides by this, Gecko is happy to work with it.</p> <p>Suppose you want to generate a random date of birth for every person in your synthetic dataset. Add a new function to your script called <code>create_date_of_birth_generator</code>.</p> <pre><code>from gecko.generator import Generator\nfrom typing import Optional\n\ndef create_date_of_birth_generator(\n    start_date: str = \"1920-01-01\",  # (1)!\n    end_date: str = \"2000-01-01\",\n    rng: Optional[np.random.Generator] = None,  # (2)!\n) -&gt; Generator:\n    pass\n</code></pre> <ol> <li>If no start or end date is specified, the function will use January 1st, 1920 and January 1st, 2000 as the default boundaries.</li> <li>Almost all built-in functions in Gecko allow a custom RNG to be passed in. If no RNG is specified, a new RNG is used. It's a good idea to stick to this convention in your own generators.</li> </ol> <p>Some more boilerplate code is required. First, if <code>rng</code> is <code>None</code>, then the function should use a new RNG with a random starting point. Second, your function needs to return a generator, so create a nested function that follows the requirements for it to be recognized as a generator.</p> <pre><code>import pandas as pd\nfrom gecko.generator import Generator\nfrom typing import Optional\n\ndef create_date_of_birth_generator(\n    start_date: str = \"1920-01-01\", \n    end_date: str = \"2000-01-01\",\n    rng: Optional[np.random.Generator] = None,\n) -&gt; Generator:\n    if rng is None:  # (1)!\n        rng = np.random.default_rng()\n\n    def _generate(count: int) -&gt; list[pd.Series]:  # (2)!\n        return []\n\n    return _generate  # (3)!\n</code></pre> <ol> <li>If no RNG is supplied to this function, then it will use a new RNG with a random starting point. See the Numpy docs on <code>default_rng</code> for more information.</li> <li>This is the actual generator function that will take care of generating random data. It must take in a number and return a list of series.</li> <li>The generator is returned by your function. This means whenever you call <code>create_date_of_birth_generator</code> in your code, you will actually receive the nested <code>_generate</code> function.</li> </ol> <p>The way we're going to generate random dates in this example is to take the start date and add a random amount of days to it. Numpy offers functions that simplify working with dates and times.</p> <p>First, you need to parse the start and end dates into Numpy's <code>datetime64</code> objects. To get the amount of days between the start and end date, subtract the start date from the end date to obtain a <code>timedelta64</code>.</p> <p>Converting <code>timedelta64</code> into a number of days isn't as trivial though. To make this work, divide it by a time delta of one day. This returns a floating point number, which you can then convert into an integer.</p> <pre><code>import numpy as np\nimport pandas as pd\n\nfrom typing import Optional\nfrom gecko.generator import Generator\n\ndef create_date_of_birth_generator(\n    start_date: str = \"1920-01-01\", \n    end_date: str = \"2000-01-01\",\n    rng: Optional[np.random.Generator] = None,\n) -&gt; Generator:\n    if rng is None:\n        rng = np.random.default_rng()\n\n    def _generate(count: int) -&gt; list[pd.Series]:\n        start_dt = np.datetime64(start_date)  # (1)!\n        end_dt = np.datetime64(end_date)\n        delta = end_dt - start_dt  # (2)!\n        days_delta = int(delta / np.timedelta64(1, \"D\")) # (3)!\n\n        return []\n\n    return _generate\n</code></pre> <ol> <li>Parsing dates in Numpy is as simple as wrapping it into <code>np.datetime64</code>, given that the date is provided in ISO 8601 format.</li> <li>Subtracting <code>np.datetime64</code> from one another yields a <code>np.timedelta64</code>.</li> <li>By diving the time delta by one day, this line will return the amount of days in the time delta as a floating point number. It is then converted into an integer.</li> </ol> <p>Now you can generate random days to add to the start date. Use Numpy's RNG <code>integers</code> function to quickly generate many numbers at once. By setting <code>endpoint</code> to <code>True</code>, you're ensuring that the upper bound is included in the random number generation.</p> <p>Armed with a random list of numbers, you can add them to the start date and receive a list of random dates ranging from the specified start to the end date. Since the list will contain instances of <code>datetime64</code>, they will need to be converted into strings. <code>np.char.mod</code> takes care of that.</p> <p>Beware that a generator must return a list of series, so even if you're returning a single series, you must wrap it into a list.</p> <pre><code>import numpy as np\nimport pandas as pd\n\nfrom typing import Optional\nfrom gecko.generator import Generator\n\ndef create_date_of_birth_generator(\n    start_date: str = \"1920-01-01\", \n    end_date: str = \"2000-01-01\",\n    rng: Optional[np.random.Generator] = None,\n) -&gt; Generator:\n    if rng is None:\n        rng = np.random.default_rng()\n\n    def _generate(count: int) -&gt; list[pd.Series]:\n        start_dt = np.datetime64(start_date)\n        end_dt = np.datetime64(end_date)\n        delta = end_dt - start_dt\n        days_delta = int(delta / np.timedelta64(1, \"D\"))\n\n        random_days = rng.integers(low=0, high=days_delta, size=count, endpoint=True)  # (1)!\n        random_dates = start_dt + random_days  # (2)!\n        random_date_strs = np.char.mod(\"%s\", random_dates)  # (3)!\n\n        return [pd.Series(random_date_strs)]  # (4)!\n\n    return _generate\n</code></pre> <ol> <li>Numpy's RNG functions are optimized to generate many numbers at once. Gecko uses these functions wherever possible. In your code, you should try to use these functions as well as to not affect performance when generating millions of records.</li> <li>By adding the list of random days to the starting date, we get a list of random dates.</li> <li>The list of random dates consists of <code>datetime64</code> instances, so they need to be converted to strings before being returned.</li> <li>Generators must always return a list of series, so even a single series must be wrapped into a list.</li> </ol> <p>And there you go! Now you have your own generator that you can plug into Gecko with no issues. Expand the <code>generate_data_frame</code> function by adding your own generator.</p> <pre><code>def generate_data_frame(count, rng): \n    gen_last_name = generator.from_frequency_table(\n        \"gecko-data/de_DE/last-name.csv\", \n        header=True,  \n        value_column=\"last_name\",\n        freq_column=\"count\",\n        rng=rng,\n    )\n\n    gen_given_name_gender = generator.from_multicolumn_frequency_table(\n        \"gecko-data/de_DE/given-name-gender.csv\",\n        header=True,\n        value_columns=[\"given_name\", \"gender\"],\n        freq_column=\"count\",\n        rng=rng,\n    )\n\n    gen_street_municip_postcode = generator.from_multicolumn_frequency_table(\n        \"gecko-data/de_DE/street-municipality-postcode.csv\",\n        header=True,\n        value_columns=[\"street_name\", \"municipality\", \"postcode\"], \n        freq_column=\"count\",\n        rng=rng,\n    )\n\n    gen_date_of_birth = create_date_of_birth_generator(rng=rng)  # (1)!\n\n    return generator.to_dataframe({\n        (\"given_name\", \"gender\"): gen_given_name_gender,\n        \"last_name\": gen_last_name,\n        (\"street_name\", \"municipality\", \"postcode\"): gen_street_municip_postcode,\n        \"date_of_birth\": gen_date_of_birth,\n    }, count)\n</code></pre> <ol> <li>Now you have a reusable generator with a configurable start and end date. As long as a function returns a generator, it can be seamlessly used with Gecko.</li> <li>As with all other generators, your custom generator is accepted by <code>to_dataframe</code> by simply assigning it a column name.</li> </ol>"}]}